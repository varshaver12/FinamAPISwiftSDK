// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/tradeapi/v1/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Timeframe.
/// Таймфрейм.
struct Proto_Tradeapi_V1_TimeFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timeframe units.
  /// Единицы измерения таймфрейма.
  var timeUnit: Proto_Tradeapi_V1_TimeFrame.Unit = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Unit: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Value is not specified. Do not use.
    /// Значение не указано. Не использовать.
    case unspecified // = 0

    /// Munute.
    /// Минута.
    case minute // = 1

    /// Hour.
    /// Час.
    case hour // = 2

    /// Day.
    /// День.
    case day // = 3

    /// Week.
    /// Неделя.
    case week // = 4

    /// Month.
    /// Месяц.
    case month // = 5

    /// Quarter.
    /// Квартал.
    case quarter // = 6

    /// Year.
    /// Год.
    case year // = 7
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .minute
      case 2: self = .hour
      case 3: self = .day
      case 4: self = .week
      case 5: self = .month
      case 6: self = .quarter
      case 7: self = .year
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .minute: return 1
      case .hour: return 2
      case .day: return 3
      case .week: return 4
      case .month: return 5
      case .quarter: return 6
      case .year: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_TimeFrame.Unit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_TimeFrame.Unit] = [
    .unspecified,
    .minute,
    .hour,
    .day,
    .week,
    .month,
    .quarter,
    .year,
  ]
}

#endif  // swift(>=4.2)

/// Subscription/unsubscription.
/// Подписка/отписка.
struct Proto_Tradeapi_V1_SubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set only one parameter.
  /// Определите только одно из полей.
  var payload: Proto_Tradeapi_V1_SubscriptionRequest.OneOf_Payload? = nil

  /// OrderBook subscription request.
  /// Запрос подписки на стакан.
  var orderBookSubscribeRequest: Proto_Tradeapi_V1_OrderBookSubscribeRequest {
    get {
      if case .orderBookSubscribeRequest(let v)? = payload {return v}
      return Proto_Tradeapi_V1_OrderBookSubscribeRequest()
    }
    set {payload = .orderBookSubscribeRequest(newValue)}
  }

  /// OrderBook unsubscribe request.
  /// Запрос на отписку от стакана.
  var orderBookUnsubscribeRequest: Proto_Tradeapi_V1_OrderBookUnsubscribeRequest {
    get {
      if case .orderBookUnsubscribeRequest(let v)? = payload {return v}
      return Proto_Tradeapi_V1_OrderBookUnsubscribeRequest()
    }
    set {payload = .orderBookUnsubscribeRequest(newValue)}
  }

  /// Subscribe for trades and orders.
  /// Запрос подписки на ордера и сделки.
  var orderTradeSubscribeRequest: Proto_Tradeapi_V1_OrderTradeSubscribeRequest {
    get {
      if case .orderTradeSubscribeRequest(let v)? = payload {return v}
      return Proto_Tradeapi_V1_OrderTradeSubscribeRequest()
    }
    set {payload = .orderTradeSubscribeRequest(newValue)}
  }

  /// Cancel all previous subscription for trades and orders.
  /// Отменить все предыдущие запросы на подписки на ордера и сделки.
  var orderTradeUnsubscribeRequest: Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest {
    get {
      if case .orderTradeUnsubscribeRequest(let v)? = payload {return v}
      return Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest()
    }
    set {payload = .orderTradeUnsubscribeRequest(newValue)}
  }

  /// Keep-alive request.
  /// Keep-alive запрос.
  var keepAliveRequest: Proto_Tradeapi_V1_KeepAliveRequest {
    get {
      if case .keepAliveRequest(let v)? = payload {return v}
      return Proto_Tradeapi_V1_KeepAliveRequest()
    }
    set {payload = .keepAliveRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Set only one parameter.
  /// Определите только одно из полей.
  enum OneOf_Payload: Equatable {
    /// OrderBook subscription request.
    /// Запрос подписки на стакан.
    case orderBookSubscribeRequest(Proto_Tradeapi_V1_OrderBookSubscribeRequest)
    /// OrderBook unsubscribe request.
    /// Запрос на отписку от стакана.
    case orderBookUnsubscribeRequest(Proto_Tradeapi_V1_OrderBookUnsubscribeRequest)
    /// Subscribe for trades and orders.
    /// Запрос подписки на ордера и сделки.
    case orderTradeSubscribeRequest(Proto_Tradeapi_V1_OrderTradeSubscribeRequest)
    /// Cancel all previous subscription for trades and orders.
    /// Отменить все предыдущие запросы на подписки на ордера и сделки.
    case orderTradeUnsubscribeRequest(Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest)
    /// Keep-alive request.
    /// Keep-alive запрос.
    case keepAliveRequest(Proto_Tradeapi_V1_KeepAliveRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Tradeapi_V1_SubscriptionRequest.OneOf_Payload, rhs: Proto_Tradeapi_V1_SubscriptionRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.orderBookSubscribeRequest, .orderBookSubscribeRequest): return {
        guard case .orderBookSubscribeRequest(let l) = lhs, case .orderBookSubscribeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderBookUnsubscribeRequest, .orderBookUnsubscribeRequest): return {
        guard case .orderBookUnsubscribeRequest(let l) = lhs, case .orderBookUnsubscribeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderTradeSubscribeRequest, .orderTradeSubscribeRequest): return {
        guard case .orderTradeSubscribeRequest(let l) = lhs, case .orderTradeSubscribeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderTradeUnsubscribeRequest, .orderTradeUnsubscribeRequest): return {
        guard case .orderTradeUnsubscribeRequest(let l) = lhs, case .orderTradeUnsubscribeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keepAliveRequest, .keepAliveRequest): return {
        guard case .keepAliveRequest(let l) = lhs, case .keepAliveRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Event.
/// Событие.
struct Proto_Tradeapi_V1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// It is possible to set the only field.
  /// Только одно из полей может быть заполнено.
  var payload: Proto_Tradeapi_V1_Event.OneOf_Payload? = nil

  /// Order event.
  /// Событие с заявкой.
  var order: Proto_Tradeapi_V1_OrderEvent {
    get {
      if case .order(let v)? = payload {return v}
      return Proto_Tradeapi_V1_OrderEvent()
    }
    set {payload = .order(newValue)}
  }

  /// Trade event.
  /// Событие со сделкой.
  var trade: Proto_Tradeapi_V1_TradeEvent {
    get {
      if case .trade(let v)? = payload {return v}
      return Proto_Tradeapi_V1_TradeEvent()
    }
    set {payload = .trade(newValue)}
  }

  /// OrderBook event.
  /// Событие стакана.
  var orderBook: Proto_Tradeapi_V1_OrderBookEvent {
    get {
      if case .orderBook(let v)? = payload {return v}
      return Proto_Tradeapi_V1_OrderBookEvent()
    }
    set {payload = .orderBook(newValue)}
  }

  /// Portfolio event.
  /// Событие портфеля.
  var portfolio: Proto_Tradeapi_V1_PortfolioEvent {
    get {
      if case .portfolio(let v)? = payload {return v}
      return Proto_Tradeapi_V1_PortfolioEvent()
    }
    set {payload = .portfolio(newValue)}
  }

  /// Request execution result.
  /// Результат выполнения запроса.
  var response: Proto_Tradeapi_V1_ResponseEvent {
    get {
      if case .response(let v)? = payload {return v}
      return Proto_Tradeapi_V1_ResponseEvent()
    }
    set {payload = .response(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// It is possible to set the only field.
  /// Только одно из полей может быть заполнено.
  enum OneOf_Payload: Equatable {
    /// Order event.
    /// Событие с заявкой.
    case order(Proto_Tradeapi_V1_OrderEvent)
    /// Trade event.
    /// Событие со сделкой.
    case trade(Proto_Tradeapi_V1_TradeEvent)
    /// OrderBook event.
    /// Событие стакана.
    case orderBook(Proto_Tradeapi_V1_OrderBookEvent)
    /// Portfolio event.
    /// Событие портфеля.
    case portfolio(Proto_Tradeapi_V1_PortfolioEvent)
    /// Request execution result.
    /// Результат выполнения запроса.
    case response(Proto_Tradeapi_V1_ResponseEvent)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Tradeapi_V1_Event.OneOf_Payload, rhs: Proto_Tradeapi_V1_Event.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.order, .order): return {
        guard case .order(let l) = lhs, case .order(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trade, .trade): return {
        guard case .trade(let l) = lhs, case .trade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderBook, .orderBook): return {
        guard case .orderBook(let l) = lhs, case .orderBook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.portfolio, .portfolio): return {
        guard case .portfolio(let l) = lhs, case .portfolio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.response, .response): return {
        guard case .response(let l) = lhs, case .response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// OrderBook subscribe request.
/// Запрос подписки на стакан.
struct Proto_Tradeapi_V1_OrderBookSubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID.
  /// Идентификатор запроса.
  var requestID: String = String()

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String = String()

  /// Trading Board.
  /// Режим торгов.
  var securityBoard: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OrderBook unsubscribe request.
/// Запрос на отписку от стакана.
struct Proto_Tradeapi_V1_OrderBookUnsubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID.
  /// Идентификатор запроса.
  var requestID: String = String()

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String = String()

  /// Trading Board.
  /// Режим торгов.
  var securityBoard: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Subscribe for trades and orders.
/// Запрос подписки на ордера и сделки.
struct Proto_Tradeapi_V1_OrderTradeSubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID.
  /// Идентификатор запроса.
  var requestID: String = String()

  /// Включить сделки в подписку.
  var includeTrades: Bool = false

  /// Включить заявки в подписку.
  /// Тикер инструмента.
  var includeOrders: Bool = false

  /// Торговые коды счетов.
  var clientIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Cancel all previous subscription for trades and orders.
/// Отменить все предыдущие запросы на подписки на ордера и сделки.
struct Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID.
  /// Идентификатор запроса.
  var requestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Portfolio subscription.
/// Подписка на портфель.
struct Proto_Tradeapi_V1_PortfolioSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// What kind of data the response contains.
  /// Какие данные будут в ответе.
  var content: Proto_Tradeapi_V1_PortfolioContent {
    get {return _content ?? Proto_Tradeapi_V1_PortfolioContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _content: Proto_Tradeapi_V1_PortfolioContent? = nil
}

/// Order event.
/// Событие с заявкой.
struct Proto_Tradeapi_V1_OrderEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Order No. Appear only when an order is placed in OrderBook.
  /// Биржевой номер заявки. Появляется после того, как заявка попадает в стакан.
  var orderNo: Int64 {
    get {return _storage._orderNo}
    set {_uniqueStorage()._orderNo = newValue}
  }

  /// Transaction Id . Assigned when a command for new order creation is sent.
  /// Идентификатор транзакции. Назначается после подачи команды на создание новой заявки.
  var transactionID: Int32 {
    get {return _storage._transactionID}
    set {_uniqueStorage()._transactionID = newValue}
  }

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String {
    get {return _storage._securityCode}
    set {_uniqueStorage()._securityCode = newValue}
  }

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String {
    get {return _storage._clientID}
    set {_uniqueStorage()._clientID = newValue}
  }

  /// Order status.
  /// Состояние заявки.
  var status: Proto_Tradeapi_V1_OrderStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Transaction direction.
  /// Направление сделки.
  var buySell: Proto_Tradeapi_V1_BuySell {
    get {return _storage._buySell}
    set {_uniqueStorage()._buySell = newValue}
  }

  /// Time of Order placement in UTC.
  /// Время регистрации заявки на бирже. В UTC.
  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Lot price.
  /// Цена за лот.
  var price: Double {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  /// Volume in lots.
  /// Количество, в лотах.
  var quantity: Int32 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  /// Residual volume in lots.
  /// Неисполненный остаток, в лотах.
  var balance: Int32 {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  /// Rejection reason or conditional order resolution.
  /// Причина отказа или вердикт по условной заявке.
  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Price currency.
  /// Валюта цены инструмента.
  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  /// Conditional order properties.
  /// Параметры условной заявки.
  var condition: Proto_Tradeapi_V1_OrderCondition {
    get {return _storage._condition ?? Proto_Tradeapi_V1_OrderCondition()}
    set {_uniqueStorage()._condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  var hasCondition: Bool {return _storage._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  mutating func clearCondition() {_uniqueStorage()._condition = nil}

  /// Order lifetime.
  /// Время действия заявки.
  var validBefore: Proto_Tradeapi_V1_OrderValidBefore {
    get {return _storage._validBefore ?? Proto_Tradeapi_V1_OrderValidBefore()}
    set {_uniqueStorage()._validBefore = newValue}
  }
  /// Returns true if `validBefore` has been explicitly set.
  var hasValidBefore: Bool {return _storage._validBefore != nil}
  /// Clears the value of `validBefore`. Subsequent reads from it will return its default value.
  mutating func clearValidBefore() {_uniqueStorage()._validBefore = nil}

  /// Time of order registration on the server in UTC.
  /// Время, когда заявка была зарегистрирована на сервере. В UTC.
  var acceptedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._acceptedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._acceptedAt = newValue}
  }
  /// Returns true if `acceptedAt` has been explicitly set.
  var hasAcceptedAt: Bool {return _storage._acceptedAt != nil}
  /// Clears the value of `acceptedAt`. Subsequent reads from it will return its default value.
  mutating func clearAcceptedAt() {_uniqueStorage()._acceptedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Trade event.
/// Событие со сделкой.
struct Proto_Tradeapi_V1_TradeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String = String()

  /// Trade No.
  /// Номер сделки.
  var tradeNo: Int64 = 0

  /// Order No.
  /// Номер заявки.
  var orderNo: Int64 = 0

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Time of trade registration on stock exchange in UTC.
  /// Время исполнения сделки на бирже. В UTC.
  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  /// Volume in lots.
  /// Количество, в лотах.
  var quantity: Int64 = 0

  /// Trade Price.
  /// Цена сделки.
  var price: Double = 0

  /// Trade currency value.
  /// Объём сделки в валюте инструмента.
  var value: Double = 0

  /// Transaction direction.
  /// Направление сделки.
  var buySell: Proto_Tradeapi_V1_BuySell = .unspecified

  /// Fee, RUB.
  /// Комиссия, в рублях.
  var commission: Double = 0

  /// Trade currency.
  /// Валюта сделки.
  var currency: String = String()

  /// Accrued interest.
  /// НКД сделки.
  var accruedInterest: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Order book row.
/// Строка стакана.
struct Proto_Tradeapi_V1_OrderBookRow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Price.
  /// Цена.
  var price: Double = 0

  /// Lots.
  /// Количество лотов.
  var quantity: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OrderBook event.
/// Событие стакана.
struct Proto_Tradeapi_V1_OrderBookEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String = String()

  /// Trading Board.
  /// Режим торгов.
  var securityBoard: String = String()

  /// Asks.
  /// Заявки на продажу.
  var asks: [Proto_Tradeapi_V1_OrderBookRow] = []

  /// Bids.
  /// Заявки на покупку.
  var bids: [Proto_Tradeapi_V1_OrderBookRow] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Portfolio event.
/// Событие портфеля.
struct Proto_Tradeapi_V1_PortfolioEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// What kind of data portfolio event contains.
  /// Какие данные находятся в событии портфеля.
  var content: Proto_Tradeapi_V1_PortfolioContent {
    get {return _content ?? Proto_Tradeapi_V1_PortfolioContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  /// Current equity, RUB.
  /// Текущая оценка портфеля в рублях.
  var equity: Double = 0

  /// Open Equity, RUB.
  /// Входящая оценка портфеля в рублях.
  var balance: Double = 0

  /// DEPO positions.
  /// Позиции DEPO.
  var positions: [Proto_Tradeapi_V1_PositionRow] = []

  /// Currency positions.
  /// Валютные позиции.
  var currencies: [Proto_Tradeapi_V1_CurrencyRow] = []

  /// Money positions.
  /// Денежные позиции.
  var money: [Proto_Tradeapi_V1_MoneyRow] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _content: Proto_Tradeapi_V1_PortfolioContent? = nil
}

/// Keep-alive request.
/// Keep-alive запрос.
struct Proto_Tradeapi_V1_KeepAliveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID.
  /// Идентификатор запроса.
  var requestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_Tradeapi_V1_TimeFrame: @unchecked Sendable {}
extension Proto_Tradeapi_V1_TimeFrame.Unit: @unchecked Sendable {}
extension Proto_Tradeapi_V1_SubscriptionRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_SubscriptionRequest.OneOf_Payload: @unchecked Sendable {}
extension Proto_Tradeapi_V1_Event: @unchecked Sendable {}
extension Proto_Tradeapi_V1_Event.OneOf_Payload: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderBookSubscribeRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderBookUnsubscribeRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderTradeSubscribeRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_PortfolioSubscription: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderEvent: @unchecked Sendable {}
extension Proto_Tradeapi_V1_TradeEvent: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderBookRow: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderBookEvent: @unchecked Sendable {}
extension Proto_Tradeapi_V1_PortfolioEvent: @unchecked Sendable {}
extension Proto_Tradeapi_V1_KeepAliveRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto.tradeapi.v1"

extension Proto_Tradeapi_V1_TimeFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_unit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.timeUnit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeUnit != .unspecified {
      try visitor.visitSingularEnumField(value: self.timeUnit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_TimeFrame, rhs: Proto_Tradeapi_V1_TimeFrame) -> Bool {
    if lhs.timeUnit != rhs.timeUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_TimeFrame.Unit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNIT_UNSPECIFIED"),
    1: .same(proto: "UNIT_MINUTE"),
    2: .same(proto: "UNIT_HOUR"),
    3: .same(proto: "UNIT_DAY"),
    4: .same(proto: "UNIT_WEEK"),
    5: .same(proto: "UNIT_MONTH"),
    6: .same(proto: "UNIT_QUARTER"),
    7: .same(proto: "UNIT_YEAR"),
  ]
}

extension Proto_Tradeapi_V1_SubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_book_subscribe_request"),
    2: .standard(proto: "order_book_unsubscribe_request"),
    3: .standard(proto: "order_trade_subscribe_request"),
    4: .standard(proto: "order_trade_unsubscribe_request"),
    5: .standard(proto: "keep_alive_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Tradeapi_V1_OrderBookSubscribeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderBookSubscribeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderBookSubscribeRequest(v)
        }
      }()
      case 2: try {
        var v: Proto_Tradeapi_V1_OrderBookUnsubscribeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderBookUnsubscribeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderBookUnsubscribeRequest(v)
        }
      }()
      case 3: try {
        var v: Proto_Tradeapi_V1_OrderTradeSubscribeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderTradeSubscribeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderTradeSubscribeRequest(v)
        }
      }()
      case 4: try {
        var v: Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderTradeUnsubscribeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderTradeUnsubscribeRequest(v)
        }
      }()
      case 5: try {
        var v: Proto_Tradeapi_V1_KeepAliveRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .keepAliveRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .keepAliveRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .orderBookSubscribeRequest?: try {
      guard case .orderBookSubscribeRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .orderBookUnsubscribeRequest?: try {
      guard case .orderBookUnsubscribeRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .orderTradeSubscribeRequest?: try {
      guard case .orderTradeSubscribeRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .orderTradeUnsubscribeRequest?: try {
      guard case .orderTradeUnsubscribeRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .keepAliveRequest?: try {
      guard case .keepAliveRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_SubscriptionRequest, rhs: Proto_Tradeapi_V1_SubscriptionRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "order"),
    2: .same(proto: "trade"),
    3: .standard(proto: "order_book"),
    5: .same(proto: "portfolio"),
    10: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Tradeapi_V1_OrderEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .order(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .order(v)
        }
      }()
      case 2: try {
        var v: Proto_Tradeapi_V1_TradeEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .trade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .trade(v)
        }
      }()
      case 3: try {
        var v: Proto_Tradeapi_V1_OrderBookEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderBook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderBook(v)
        }
      }()
      case 5: try {
        var v: Proto_Tradeapi_V1_PortfolioEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .portfolio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .portfolio(v)
        }
      }()
      case 10: try {
        var v: Proto_Tradeapi_V1_ResponseEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .response(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .order?: try {
      guard case .order(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .trade?: try {
      guard case .trade(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .orderBook?: try {
      guard case .orderBook(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .portfolio?: try {
      guard case .portfolio(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .response?: try {
      guard case .response(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_Event, rhs: Proto_Tradeapi_V1_Event) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderBookSubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderBookSubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "security_code"),
    3: .standard(proto: "security_board"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.securityBoard) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 2)
    }
    if !self.securityBoard.isEmpty {
      try visitor.visitSingularStringField(value: self.securityBoard, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderBookSubscribeRequest, rhs: Proto_Tradeapi_V1_OrderBookSubscribeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.securityBoard != rhs.securityBoard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderBookUnsubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderBookUnsubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "security_code"),
    3: .standard(proto: "security_board"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.securityBoard) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 2)
    }
    if !self.securityBoard.isEmpty {
      try visitor.visitSingularStringField(value: self.securityBoard, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderBookUnsubscribeRequest, rhs: Proto_Tradeapi_V1_OrderBookUnsubscribeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.securityBoard != rhs.securityBoard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderTradeSubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderTradeSubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "include_trades"),
    3: .standard(proto: "include_orders"),
    4: .standard(proto: "client_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeTrades) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeOrders) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.clientIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if self.includeTrades != false {
      try visitor.visitSingularBoolField(value: self.includeTrades, fieldNumber: 2)
    }
    if self.includeOrders != false {
      try visitor.visitSingularBoolField(value: self.includeOrders, fieldNumber: 3)
    }
    if !self.clientIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.clientIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderTradeSubscribeRequest, rhs: Proto_Tradeapi_V1_OrderTradeSubscribeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.includeTrades != rhs.includeTrades {return false}
    if lhs.includeOrders != rhs.includeOrders {return false}
    if lhs.clientIds != rhs.clientIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderTradeUnsubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest, rhs: Proto_Tradeapi_V1_OrderTradeUnsubscribeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_PortfolioSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortfolioSubscription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_PortfolioSubscription, rhs: Proto_Tradeapi_V1_PortfolioSubscription) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_no"),
    2: .standard(proto: "transaction_id"),
    3: .standard(proto: "security_code"),
    4: .standard(proto: "client_id"),
    5: .same(proto: "status"),
    6: .standard(proto: "buy_sell"),
    7: .standard(proto: "created_at"),
    8: .same(proto: "price"),
    9: .same(proto: "quantity"),
    10: .same(proto: "balance"),
    11: .same(proto: "message"),
    12: .same(proto: "currency"),
    13: .same(proto: "condition"),
    14: .standard(proto: "valid_before"),
    15: .standard(proto: "accepted_at"),
  ]

  fileprivate class _StorageClass {
    var _orderNo: Int64 = 0
    var _transactionID: Int32 = 0
    var _securityCode: String = String()
    var _clientID: String = String()
    var _status: Proto_Tradeapi_V1_OrderStatus = .unspecified
    var _buySell: Proto_Tradeapi_V1_BuySell = .unspecified
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _price: Double = 0
    var _quantity: Int32 = 0
    var _balance: Int32 = 0
    var _message: String = String()
    var _currency: String = String()
    var _condition: Proto_Tradeapi_V1_OrderCondition? = nil
    var _validBefore: Proto_Tradeapi_V1_OrderValidBefore? = nil
    var _acceptedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _orderNo = source._orderNo
      _transactionID = source._transactionID
      _securityCode = source._securityCode
      _clientID = source._clientID
      _status = source._status
      _buySell = source._buySell
      _createdAt = source._createdAt
      _price = source._price
      _quantity = source._quantity
      _balance = source._balance
      _message = source._message
      _currency = source._currency
      _condition = source._condition
      _validBefore = source._validBefore
      _acceptedAt = source._acceptedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._orderNo) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._transactionID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._securityCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._clientID) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._buySell) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._price) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._quantity) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._balance) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._condition) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._validBefore) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._acceptedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._orderNo != 0 {
        try visitor.visitSingularInt64Field(value: _storage._orderNo, fieldNumber: 1)
      }
      if _storage._transactionID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._transactionID, fieldNumber: 2)
      }
      if !_storage._securityCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityCode, fieldNumber: 3)
      }
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 4)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._buySell != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._buySell, fieldNumber: 6)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._price != 0 {
        try visitor.visitSingularDoubleField(value: _storage._price, fieldNumber: 8)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._quantity, fieldNumber: 9)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularInt32Field(value: _storage._balance, fieldNumber: 10)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 11)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 12)
      }
      try { if let v = _storage._condition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._validBefore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._acceptedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderEvent, rhs: Proto_Tradeapi_V1_OrderEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._orderNo != rhs_storage._orderNo {return false}
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._securityCode != rhs_storage._securityCode {return false}
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._buySell != rhs_storage._buySell {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._condition != rhs_storage._condition {return false}
        if _storage._validBefore != rhs_storage._validBefore {return false}
        if _storage._acceptedAt != rhs_storage._acceptedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_TradeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "security_code"),
    2: .standard(proto: "trade_no"),
    3: .standard(proto: "order_no"),
    4: .standard(proto: "client_id"),
    5: .standard(proto: "created_at"),
    6: .same(proto: "quantity"),
    7: .same(proto: "price"),
    8: .same(proto: "value"),
    9: .standard(proto: "buy_sell"),
    10: .same(proto: "commission"),
    11: .same(proto: "currency"),
    12: .standard(proto: "accrued_interest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.tradeNo) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.orderNo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.price) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.buySell) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.commission) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self.accruedInterest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 1)
    }
    if self.tradeNo != 0 {
      try visitor.visitSingularInt64Field(value: self.tradeNo, fieldNumber: 2)
    }
    if self.orderNo != 0 {
      try visitor.visitSingularInt64Field(value: self.orderNo, fieldNumber: 3)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 6)
    }
    if self.price != 0 {
      try visitor.visitSingularDoubleField(value: self.price, fieldNumber: 7)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 8)
    }
    if self.buySell != .unspecified {
      try visitor.visitSingularEnumField(value: self.buySell, fieldNumber: 9)
    }
    if self.commission != 0 {
      try visitor.visitSingularDoubleField(value: self.commission, fieldNumber: 10)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 11)
    }
    if self.accruedInterest != 0 {
      try visitor.visitSingularDoubleField(value: self.accruedInterest, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_TradeEvent, rhs: Proto_Tradeapi_V1_TradeEvent) -> Bool {
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.tradeNo != rhs.tradeNo {return false}
    if lhs.orderNo != rhs.orderNo {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.price != rhs.price {return false}
    if lhs.value != rhs.value {return false}
    if lhs.buySell != rhs.buySell {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs.accruedInterest != rhs.accruedInterest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderBookRow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderBookRow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "price", json: "p"),
    2: .unique(proto: "quantity", json: "q"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.price != 0 {
      try visitor.visitSingularDoubleField(value: self.price, fieldNumber: 1)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderBookRow, rhs: Proto_Tradeapi_V1_OrderBookRow) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderBookEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderBookEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "security_code"),
    2: .standard(proto: "security_board"),
    3: .same(proto: "asks"),
    4: .same(proto: "bids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.securityBoard) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 1)
    }
    if !self.securityBoard.isEmpty {
      try visitor.visitSingularStringField(value: self.securityBoard, fieldNumber: 2)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 3)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderBookEvent, rhs: Proto_Tradeapi_V1_OrderBookEvent) -> Bool {
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.securityBoard != rhs.securityBoard {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_PortfolioEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortfolioEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "content"),
    3: .same(proto: "equity"),
    4: .same(proto: "balance"),
    5: .same(proto: "positions"),
    6: .same(proto: "currencies"),
    7: .same(proto: "money"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.equity) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.balance) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.positions) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.currencies) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.money) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.equity != 0 {
      try visitor.visitSingularDoubleField(value: self.equity, fieldNumber: 3)
    }
    if self.balance != 0 {
      try visitor.visitSingularDoubleField(value: self.balance, fieldNumber: 4)
    }
    if !self.positions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positions, fieldNumber: 5)
    }
    if !self.currencies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.currencies, fieldNumber: 6)
    }
    if !self.money.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.money, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_PortfolioEvent, rhs: Proto_Tradeapi_V1_PortfolioEvent) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.equity != rhs.equity {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.positions != rhs.positions {return false}
    if lhs.currencies != rhs.currencies {return false}
    if lhs.money != rhs.money {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_KeepAliveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeepAliveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_KeepAliveRequest, rhs: Proto_Tradeapi_V1_KeepAliveRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
