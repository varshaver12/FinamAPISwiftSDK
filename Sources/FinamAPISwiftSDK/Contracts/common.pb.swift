// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/tradeapi/v1/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Market.
/// Рынок.
enum Proto_Tradeapi_V1_Market: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Moscow Exchange Stock market.
  /// Фондовый рынок Московской Биржи.
  case stock // = 1

  /// Moscow Exchange Derivative market.
  /// Срочный рынок Московской Биржи.
  case forts // = 4

  /// Saint-Petersburg Exchange.
  /// Санкт-Петербургская биржа.
  case spbex // = 7

  /// US Stock market.
  /// Фондовый рынок США.
  case mma // = 14

  /// Moscow Exchange Currency market.
  /// Валютный рынок Московской Биржи.
  case ets // = 15

  /// Moscow Exchange Bond market.
  /// Долговой рынок Московской Биржи.
  case bonds // = 20

  /// Moscow Exchange option market.
  /// Рынок опционов Московской Биржи.
  case options // = 21
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .stock
    case 4: self = .forts
    case 7: self = .spbex
    case 14: self = .mma
    case 15: self = .ets
    case 20: self = .bonds
    case 21: self = .options
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .stock: return 1
    case .forts: return 4
    case .spbex: return 7
    case .mma: return 14
    case .ets: return 15
    case .bonds: return 20
    case .options: return 21
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_Market: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_Market] = [
    .unspecified,
    .stock,
    .forts,
    .spbex,
    .mma,
    .ets,
    .bonds,
    .options,
  ]
}

#endif  // swift(>=4.2)

/// Transaction direction.
/// Направление сделки.
enum Proto_Tradeapi_V1_BuySell: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Sell.
  /// Продажа.
  case sell // = 1

  /// Buy.
  /// Покупка.
  case buy // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .sell
    case 2: self = .buy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .sell: return 1
    case .buy: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_BuySell: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_BuySell] = [
    .unspecified,
    .sell,
    .buy,
  ]
}

#endif  // swift(>=4.2)

/// Time validation for order.
/// Установка временных рамок действия заявки.
enum Proto_Tradeapi_V1_OrderValidBeforeType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Order is valid till the end of the current session.
  /// Заявка действует до конца сессии.
  case tillEndSession // = 1

  /// Order is valid till cancellation.
  /// Заявка действует, пока не будет отменена.
  case tillCancelled // = 2

  /// Order is valid till specified moment. OrderValidBefore.time parameter must be set.
  /// Заявка действует до указанного времени. Параметр OrderValidBefore.time должно быть установлен.
  case exactTime // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .tillEndSession
    case 2: self = .tillCancelled
    case 3: self = .exactTime
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .tillEndSession: return 1
    case .tillCancelled: return 2
    case .exactTime: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_OrderValidBeforeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_OrderValidBeforeType] = [
    .unspecified,
    .tillEndSession,
    .tillCancelled,
    .exactTime,
  ]
}

#endif  // swift(>=4.2)

/// Request execution result.
/// Результат выполнения запроса.
struct Proto_Tradeapi_V1_ResponseEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID.
  /// Идентификатор запроса.
  var requestID: String = String()

  /// Request execution result.
  /// Результат выполнения запроса.
  var success: Bool = false

  /// Errors in request execution.
  /// Ошибки выполнения запроса.
  var errors: [Proto_Tradeapi_V1_Error] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Error data.
/// Данные об ошибке.
struct Proto_Tradeapi_V1_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error code.
  /// Код ошибки.
  var code: String = String()

  /// Error message.
  /// Сообщение об ошибке.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Order time condition.
/// Условие по времени действия заявки.
struct Proto_Tradeapi_V1_OrderValidBefore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Condition type.
  /// Тип условия.
  var type: Proto_Tradeapi_V1_OrderValidBeforeType = .unspecified

  /// Order lifetime.
  /// Время действия заявки.
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Real number with fixed precision (including integers).
/// The total value is calculated as follows: num * 10^-scale.
/// https://en.wikipedia.org/wiki/Scientific_notation
/// Example:
/// The number "250.655" is Decimal type with num = 250655 and scale = 3, 250.655 = 250655 * 10^-3
struct Proto_Tradeapi_V1_Decimal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mantissa.
  /// Мантисса.
  var num: Int64 = 0

  /// exponent for base 10.
  /// Экспонента.
  var scale: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_Tradeapi_V1_Market: @unchecked Sendable {}
extension Proto_Tradeapi_V1_BuySell: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderValidBeforeType: @unchecked Sendable {}
extension Proto_Tradeapi_V1_ResponseEvent: @unchecked Sendable {}
extension Proto_Tradeapi_V1_Error: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderValidBefore: @unchecked Sendable {}
extension Proto_Tradeapi_V1_Decimal: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto.tradeapi.v1"

extension Proto_Tradeapi_V1_Market: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MARKET_UNSPECIFIED"),
    1: .same(proto: "MARKET_STOCK"),
    4: .same(proto: "MARKET_FORTS"),
    7: .same(proto: "MARKET_SPBEX"),
    14: .same(proto: "MARKET_MMA"),
    15: .same(proto: "MARKET_ETS"),
    20: .same(proto: "MARKET_BONDS"),
    21: .same(proto: "MARKET_OPTIONS"),
  ]
}

extension Proto_Tradeapi_V1_BuySell: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUY_SELL_UNSPECIFIED"),
    1: .same(proto: "BUY_SELL_SELL"),
    2: .same(proto: "BUY_SELL_BUY"),
  ]
}

extension Proto_Tradeapi_V1_OrderValidBeforeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_VALID_BEFORE_TYPE_UNSPECIFIED"),
    1: .same(proto: "ORDER_VALID_BEFORE_TYPE_TILL_END_SESSION"),
    2: .same(proto: "ORDER_VALID_BEFORE_TYPE_TILL_CANCELLED"),
    3: .same(proto: "ORDER_VALID_BEFORE_TYPE_EXACT_TIME"),
  ]
}

extension Proto_Tradeapi_V1_ResponseEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "success"),
    3: .same(proto: "errors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_ResponseEvent, rhs: Proto_Tradeapi_V1_ResponseEvent) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.success != rhs.success {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_Error, rhs: Proto_Tradeapi_V1_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_OrderValidBefore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderValidBefore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderValidBefore, rhs: Proto_Tradeapi_V1_OrderValidBefore) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_Decimal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Decimal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.num) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.scale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.num != 0 {
      try visitor.visitSingularInt64Field(value: self.num, fieldNumber: 1)
    }
    if self.scale != 0 {
      try visitor.visitSingularUInt32Field(value: self.scale, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_Decimal, rhs: Proto_Tradeapi_V1_Decimal) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
