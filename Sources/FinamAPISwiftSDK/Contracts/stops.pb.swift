// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/tradeapi/v1/stops.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Stop order status.
/// Состояние заявки.
enum Proto_Tradeapi_V1_StopStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Order is not in OrderBook.
  /// Заявка не выставлена.
  case none // = 1

  /// Order is in OrderBook.
  /// Заявка выставлена.
  case active // = 2

  /// Order is cancelled.
  /// Заявка отменена.
  case cancelled // = 3

  /// Order is executed.
  /// Заявка выполнена.
  case executed // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .none
    case 2: self = .active
    case 3: self = .cancelled
    case 4: self = .executed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .none: return 1
    case .active: return 2
    case .cancelled: return 3
    case .executed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_StopStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_StopStatus] = [
    .unspecified,
    .none,
    .active,
    .cancelled,
    .executed,
  ]
}

#endif  // swift(>=4.2)

/// Stop quantity units.
/// Единицы объема стоп-заявки.
enum Proto_Tradeapi_V1_StopQuantityUnits: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Percent.
  /// Значение а процентах.
  case percent // = 1

  /// Lots.
  /// Значение в лотах.
  case lots // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .percent
    case 2: self = .lots
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .percent: return 1
    case .lots: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_StopQuantityUnits: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_StopQuantityUnits] = [
    .unspecified,
    .percent,
    .lots,
  ]
}

#endif  // swift(>=4.2)

/// Stop price units.
/// Единицы цены стоп-заявки.
enum Proto_Tradeapi_V1_StopPriceUnits: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Percent.
  /// Значение а процентах.
  case percent // = 1

  /// Lots.
  /// Значение в единицах цены.
  case pips // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .percent
    case 2: self = .pips
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .percent: return 1
    case .pips: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_StopPriceUnits: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_StopPriceUnits] = [
    .unspecified,
    .percent,
    .pips,
  ]
}

#endif  // swift(>=4.2)

/// Stop Order.
/// Стоп-заявка.
struct Proto_Tradeapi_V1_Stop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stop Order Id.
  /// Идентификатор стоп-заявки.
  var stopID: Int32 {
    get {return _storage._stopID}
    set {_uniqueStorage()._stopID = newValue}
  }

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String {
    get {return _storage._securityCode}
    set {_uniqueStorage()._securityCode = newValue}
  }

  /// Security Board.
  /// Основной режим торгов инструмента.
  var securityBoard: String {
    get {return _storage._securityBoard}
    set {_uniqueStorage()._securityBoard = newValue}
  }

  /// Market.
  /// Рынок.
  var market: Proto_Tradeapi_V1_Market {
    get {return _storage._market}
    set {_uniqueStorage()._market = newValue}
  }

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String {
    get {return _storage._clientID}
    set {_uniqueStorage()._clientID = newValue}
  }

  /// Transaction direction.
  /// Направление сделки.
  var buySell: Proto_Tradeapi_V1_BuySell {
    get {return _storage._buySell}
    set {_uniqueStorage()._buySell = newValue}
  }

  /// Expiration date for FORTS order.
  /// Дата экспирации заявки FORTS.
  var expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expirationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  var hasExpirationDate: Bool {return _storage._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  mutating func clearExpirationDate() {_uniqueStorage()._expirationDate = nil}

  /// Linked order ID.
  /// Биржевой номер связанной (активной) заявки.
  var linkOrder: Int64 {
    get {return _storage._linkOrder}
    set {_uniqueStorage()._linkOrder = newValue}
  }

  /// Order lifetime.
  /// Время действия заявки.
  var validBefore: Proto_Tradeapi_V1_OrderValidBefore {
    get {return _storage._validBefore ?? Proto_Tradeapi_V1_OrderValidBefore()}
    set {_uniqueStorage()._validBefore = newValue}
  }
  /// Returns true if `validBefore` has been explicitly set.
  var hasValidBefore: Bool {return _storage._validBefore != nil}
  /// Clears the value of `validBefore`. Subsequent reads from it will return its default value.
  mutating func clearValidBefore() {_uniqueStorage()._validBefore = nil}

  /// Order status.
  /// Состояние заявки.
  var status: Proto_Tradeapi_V1_StopStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Rejection reason or conditional order resolution.
  /// Причина отказа или вердикт по условной заявке.
  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Order No.
  /// Номер заявки, полученной в результате исполнения стопа.
  var orderNo: Int64 {
    get {return _storage._orderNo}
    set {_uniqueStorage()._orderNo = newValue}
  }

  /// Trade No.
  /// Номер сделки, которая привела к исполнению стопа.
  var tradeNo: Int64 {
    get {return _storage._tradeNo}
    set {_uniqueStorage()._tradeNo = newValue}
  }

  /// Time of order registration on the server in UTC.
  /// Время, когда заявка была зарегистрирована на сервере. В UTC.
  var acceptedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._acceptedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._acceptedAt = newValue}
  }
  /// Returns true if `acceptedAt` has been explicitly set.
  var hasAcceptedAt: Bool {return _storage._acceptedAt != nil}
  /// Clears the value of `acceptedAt`. Subsequent reads from it will return its default value.
  mutating func clearAcceptedAt() {_uniqueStorage()._acceptedAt = nil}

  /// Time of order canceled on the server in UTC.
  /// Время, когда заявка была отменена на сервере. В UTC.
  var canceledAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._canceledAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._canceledAt = newValue}
  }
  /// Returns true if `canceledAt` has been explicitly set.
  var hasCanceledAt: Bool {return _storage._canceledAt != nil}
  /// Clears the value of `canceledAt`. Subsequent reads from it will return its default value.
  mutating func clearCanceledAt() {_uniqueStorage()._canceledAt = nil}

  /// Price currency.
  /// Валюта цены.
  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  /// Take profit: local extremum.
  /// Тейк профит: текущий локальный экстремум.
  var takeProfitExtremum: Double {
    get {return _storage._takeProfitExtremum}
    set {_uniqueStorage()._takeProfitExtremum = newValue}
  }

  /// Take profit: correction level.
  /// Тейк профит: текущий уровень коррекции.
  var takeProfitLevel: Double {
    get {return _storage._takeProfitLevel}
    set {_uniqueStorage()._takeProfitLevel = newValue}
  }

  /// Stop loss.
  /// Стоп лосс.
  var stopLoss: Proto_Tradeapi_V1_StopLoss {
    get {return _storage._stopLoss ?? Proto_Tradeapi_V1_StopLoss()}
    set {_uniqueStorage()._stopLoss = newValue}
  }
  /// Returns true if `stopLoss` has been explicitly set.
  var hasStopLoss: Bool {return _storage._stopLoss != nil}
  /// Clears the value of `stopLoss`. Subsequent reads from it will return its default value.
  mutating func clearStopLoss() {_uniqueStorage()._stopLoss = nil}

  /// Take profit.
  /// Тейк профит.
  var takeProfit: Proto_Tradeapi_V1_TakeProfit {
    get {return _storage._takeProfit ?? Proto_Tradeapi_V1_TakeProfit()}
    set {_uniqueStorage()._takeProfit = newValue}
  }
  /// Returns true if `takeProfit` has been explicitly set.
  var hasTakeProfit: Bool {return _storage._takeProfit != nil}
  /// Clears the value of `takeProfit`. Subsequent reads from it will return its default value.
  mutating func clearTakeProfit() {_uniqueStorage()._takeProfit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StopLoss order.
/// Стоп лосс заявка.
struct Proto_Tradeapi_V1_StopLoss {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Activation price.
  /// Цена активации.
  var activationPrice: Double = 0

  /// Price.
  /// Цена заявки.
  var price: Double = 0

  /// Market price.
  /// По рынку.
  var marketPrice: Bool = false

  /// Quantity.
  /// Количество.
  var quantity: Proto_Tradeapi_V1_StopQuantity {
    get {return _quantity ?? Proto_Tradeapi_V1_StopQuantity()}
    set {_quantity = newValue}
  }
  /// Returns true if `quantity` has been explicitly set.
  var hasQuantity: Bool {return self._quantity != nil}
  /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
  mutating func clearQuantity() {self._quantity = nil}

  /// Time, seconds.
  /// Защитное время, сек.
  var time: Int32 = 0

  /// Use credit.
  /// Использовать кредит.
  var useCredit: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _quantity: Proto_Tradeapi_V1_StopQuantity? = nil
}

/// TakeProfit order.
/// Тейк профит заявка.
struct Proto_Tradeapi_V1_TakeProfit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Activation price.
  /// Цена активации.
  var activationPrice: Double = 0

  /// Correction.
  /// Коррекция.
  var correctionPrice: Proto_Tradeapi_V1_StopPrice {
    get {return _correctionPrice ?? Proto_Tradeapi_V1_StopPrice()}
    set {_correctionPrice = newValue}
  }
  /// Returns true if `correctionPrice` has been explicitly set.
  var hasCorrectionPrice: Bool {return self._correctionPrice != nil}
  /// Clears the value of `correctionPrice`. Subsequent reads from it will return its default value.
  mutating func clearCorrectionPrice() {self._correctionPrice = nil}

  /// Spread price.
  /// Защитный спрэд.
  var spreadPrice: Proto_Tradeapi_V1_StopPrice {
    get {return _spreadPrice ?? Proto_Tradeapi_V1_StopPrice()}
    set {_spreadPrice = newValue}
  }
  /// Returns true if `spreadPrice` has been explicitly set.
  var hasSpreadPrice: Bool {return self._spreadPrice != nil}
  /// Clears the value of `spreadPrice`. Subsequent reads from it will return its default value.
  mutating func clearSpreadPrice() {self._spreadPrice = nil}

  /// Market price.
  /// По рынку.
  var marketPrice: Bool = false

  /// Quantity.
  /// Количество.
  var quantity: Proto_Tradeapi_V1_StopQuantity {
    get {return _quantity ?? Proto_Tradeapi_V1_StopQuantity()}
    set {_quantity = newValue}
  }
  /// Returns true if `quantity` has been explicitly set.
  var hasQuantity: Bool {return self._quantity != nil}
  /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
  mutating func clearQuantity() {self._quantity = nil}

  /// Time, seconds.
  /// Защитное время, сек.
  var time: Int32 = 0

  /// Use credit.
  /// Использовать кредит.
  var useCredit: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _correctionPrice: Proto_Tradeapi_V1_StopPrice? = nil
  fileprivate var _spreadPrice: Proto_Tradeapi_V1_StopPrice? = nil
  fileprivate var _quantity: Proto_Tradeapi_V1_StopQuantity? = nil
}

/// Stop quantity.
/// Объем стоп-заявки.
struct Proto_Tradeapi_V1_StopQuantity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value.
  /// Значение объема.
  var value: Double = 0

  /// Units.
  /// Единицы объема.
  var units: Proto_Tradeapi_V1_StopQuantityUnits = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Stop price.
/// Цена стоп-заявки.
struct Proto_Tradeapi_V1_StopPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value.
  /// Значение цены.
  var value: Double = 0

  /// Units.
  /// Единицы цены.
  var units: Proto_Tradeapi_V1_StopPriceUnits = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for Stop Order cancellation.
/// Запрос на снятие стоп-заявки.
struct Proto_Tradeapi_V1_CancelStopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Stop Order Id.
  /// Идентификатор стоп-заявки.
  var stopID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result of Stop Order cancellation.
/// Результат отмены стоп-заявки.
struct Proto_Tradeapi_V1_CancelStopResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Stop Order Id.
  /// Идентификатор стоп-заявки.
  var stopID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for the list of Stop Orders.
/// Запрос стоп-заявок.
struct Proto_Tradeapi_V1_GetStopsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Include executed stops in response.
  /// Вернуть исполненные стоп-заявки.
  var includeExecuted: Bool = false

  /// Include canceled stops in response.
  /// Вернуть отмененные стоп-заявки.
  var includeCanceled: Bool = false

  /// Include active stops in response.
  /// Вернуть активные стоп-заявки.
  var includeActive: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result of Stop Orders request.
/// Результат запроса стоп-заявок.
struct Proto_Tradeapi_V1_GetStopsResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Stop Orders List.
  /// Список стоп-заявок.
  var stops: [Proto_Tradeapi_V1_Stop] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// New Stop Order request.
/// Запрос на выставление стоп заявки.
struct Proto_Tradeapi_V1_NewStopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String {
    get {return _storage._clientID}
    set {_uniqueStorage()._clientID = newValue}
  }

  /// Trading Board.
  /// Режим торгов.
  var securityBoard: String {
    get {return _storage._securityBoard}
    set {_uniqueStorage()._securityBoard = newValue}
  }

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String {
    get {return _storage._securityCode}
    set {_uniqueStorage()._securityCode = newValue}
  }

  /// Transaction direction.
  /// Направление сделки.
  var buySell: Proto_Tradeapi_V1_BuySell {
    get {return _storage._buySell}
    set {_uniqueStorage()._buySell = newValue}
  }

  /// Stop loss.
  /// Стоп лосс.
  var stopLoss: Proto_Tradeapi_V1_StopLoss {
    get {return _storage._stopLoss ?? Proto_Tradeapi_V1_StopLoss()}
    set {_uniqueStorage()._stopLoss = newValue}
  }
  /// Returns true if `stopLoss` has been explicitly set.
  var hasStopLoss: Bool {return _storage._stopLoss != nil}
  /// Clears the value of `stopLoss`. Subsequent reads from it will return its default value.
  mutating func clearStopLoss() {_uniqueStorage()._stopLoss = nil}

  /// Take profit.
  /// Тейк профит.
  var takeProfit: Proto_Tradeapi_V1_TakeProfit {
    get {return _storage._takeProfit ?? Proto_Tradeapi_V1_TakeProfit()}
    set {_uniqueStorage()._takeProfit = newValue}
  }
  /// Returns true if `takeProfit` has been explicitly set.
  var hasTakeProfit: Bool {return _storage._takeProfit != nil}
  /// Clears the value of `takeProfit`. Subsequent reads from it will return its default value.
  mutating func clearTakeProfit() {_uniqueStorage()._takeProfit = nil}

  /// Expiration date for FORTS order.
  /// Дата экспирации заявки FORTS.
  var expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expirationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  var hasExpirationDate: Bool {return _storage._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  mutating func clearExpirationDate() {_uniqueStorage()._expirationDate = nil}

  /// Linked order ID.
  /// Биржевой номер связанной (активной) заявки.
  var linkOrder: Int64 {
    get {return _storage._linkOrder}
    set {_uniqueStorage()._linkOrder = newValue}
  }

  /// Order lifetime.
  /// Время действия заявки.
  var validBefore: Proto_Tradeapi_V1_OrderValidBefore {
    get {return _storage._validBefore ?? Proto_Tradeapi_V1_OrderValidBefore()}
    set {_uniqueStorage()._validBefore = newValue}
  }
  /// Returns true if `validBefore` has been explicitly set.
  var hasValidBefore: Bool {return _storage._validBefore != nil}
  /// Clears the value of `validBefore`. Subsequent reads from it will return its default value.
  mutating func clearValidBefore() {_uniqueStorage()._validBefore = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Result of new Stop Order request.
/// Результат выставления стоп заявки.
struct Proto_Tradeapi_V1_NewStopResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account Id.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Stop Order Id.
  /// Идентификатор стоп заявки.
  var stopID: Int32 = 0

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String = String()

  /// Trading Board.
  /// Режим торгов.
  var securityBoard: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_Tradeapi_V1_StopStatus: @unchecked Sendable {}
extension Proto_Tradeapi_V1_StopQuantityUnits: @unchecked Sendable {}
extension Proto_Tradeapi_V1_StopPriceUnits: @unchecked Sendable {}
extension Proto_Tradeapi_V1_Stop: @unchecked Sendable {}
extension Proto_Tradeapi_V1_StopLoss: @unchecked Sendable {}
extension Proto_Tradeapi_V1_TakeProfit: @unchecked Sendable {}
extension Proto_Tradeapi_V1_StopQuantity: @unchecked Sendable {}
extension Proto_Tradeapi_V1_StopPrice: @unchecked Sendable {}
extension Proto_Tradeapi_V1_CancelStopRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_CancelStopResult: @unchecked Sendable {}
extension Proto_Tradeapi_V1_GetStopsRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_GetStopsResult: @unchecked Sendable {}
extension Proto_Tradeapi_V1_NewStopRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_NewStopResult: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto.tradeapi.v1"

extension Proto_Tradeapi_V1_StopStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STOP_STATUS_UNSPECIFIED"),
    1: .same(proto: "STOP_STATUS_NONE"),
    2: .same(proto: "STOP_STATUS_ACTIVE"),
    3: .same(proto: "STOP_STATUS_CANCELLED"),
    4: .same(proto: "STOP_STATUS_EXECUTED"),
  ]
}

extension Proto_Tradeapi_V1_StopQuantityUnits: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STOP_QUANTITY_UNITS_UNSPECIFIED"),
    1: .same(proto: "STOP_QUANTITY_UNITS_PERCENT"),
    2: .same(proto: "STOP_QUANTITY_UNITS_LOTS"),
  ]
}

extension Proto_Tradeapi_V1_StopPriceUnits: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STOP_PRICE_UNITS_UNSPECIFIED"),
    1: .same(proto: "STOP_PRICE_UNITS_PERCENT"),
    2: .same(proto: "STOP_PRICE_UNITS_PIPS"),
  ]
}

extension Proto_Tradeapi_V1_Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Stop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stop_id"),
    2: .standard(proto: "security_code"),
    3: .standard(proto: "security_board"),
    4: .same(proto: "market"),
    5: .standard(proto: "client_id"),
    6: .standard(proto: "buy_sell"),
    7: .standard(proto: "expiration_date"),
    8: .standard(proto: "link_order"),
    9: .standard(proto: "valid_before"),
    10: .same(proto: "status"),
    11: .same(proto: "message"),
    12: .standard(proto: "order_no"),
    13: .standard(proto: "trade_no"),
    14: .standard(proto: "accepted_at"),
    15: .standard(proto: "canceled_at"),
    16: .same(proto: "currency"),
    17: .standard(proto: "take_profit_extremum"),
    18: .standard(proto: "take_profit_level"),
    19: .standard(proto: "stop_loss"),
    20: .standard(proto: "take_profit"),
  ]

  fileprivate class _StorageClass {
    var _stopID: Int32 = 0
    var _securityCode: String = String()
    var _securityBoard: String = String()
    var _market: Proto_Tradeapi_V1_Market = .unspecified
    var _clientID: String = String()
    var _buySell: Proto_Tradeapi_V1_BuySell = .unspecified
    var _expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _linkOrder: Int64 = 0
    var _validBefore: Proto_Tradeapi_V1_OrderValidBefore? = nil
    var _status: Proto_Tradeapi_V1_StopStatus = .unspecified
    var _message: String = String()
    var _orderNo: Int64 = 0
    var _tradeNo: Int64 = 0
    var _acceptedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _canceledAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currency: String = String()
    var _takeProfitExtremum: Double = 0
    var _takeProfitLevel: Double = 0
    var _stopLoss: Proto_Tradeapi_V1_StopLoss? = nil
    var _takeProfit: Proto_Tradeapi_V1_TakeProfit? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _stopID = source._stopID
      _securityCode = source._securityCode
      _securityBoard = source._securityBoard
      _market = source._market
      _clientID = source._clientID
      _buySell = source._buySell
      _expirationDate = source._expirationDate
      _linkOrder = source._linkOrder
      _validBefore = source._validBefore
      _status = source._status
      _message = source._message
      _orderNo = source._orderNo
      _tradeNo = source._tradeNo
      _acceptedAt = source._acceptedAt
      _canceledAt = source._canceledAt
      _currency = source._currency
      _takeProfitExtremum = source._takeProfitExtremum
      _takeProfitLevel = source._takeProfitLevel
      _stopLoss = source._stopLoss
      _takeProfit = source._takeProfit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._stopID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._securityCode) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._securityBoard) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._market) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._clientID) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._buySell) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._expirationDate) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._linkOrder) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._validBefore) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._orderNo) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._tradeNo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._acceptedAt) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._canceledAt) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._takeProfitExtremum) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._takeProfitLevel) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._stopLoss) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._takeProfit) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._stopID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._stopID, fieldNumber: 1)
      }
      if !_storage._securityCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityCode, fieldNumber: 2)
      }
      if !_storage._securityBoard.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityBoard, fieldNumber: 3)
      }
      if _storage._market != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._market, fieldNumber: 4)
      }
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 5)
      }
      if _storage._buySell != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._buySell, fieldNumber: 6)
      }
      try { if let v = _storage._expirationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._linkOrder != 0 {
        try visitor.visitSingularInt64Field(value: _storage._linkOrder, fieldNumber: 8)
      }
      try { if let v = _storage._validBefore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 10)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 11)
      }
      if _storage._orderNo != 0 {
        try visitor.visitSingularInt64Field(value: _storage._orderNo, fieldNumber: 12)
      }
      if _storage._tradeNo != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tradeNo, fieldNumber: 13)
      }
      try { if let v = _storage._acceptedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._canceledAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 16)
      }
      if _storage._takeProfitExtremum != 0 {
        try visitor.visitSingularDoubleField(value: _storage._takeProfitExtremum, fieldNumber: 17)
      }
      if _storage._takeProfitLevel != 0 {
        try visitor.visitSingularDoubleField(value: _storage._takeProfitLevel, fieldNumber: 18)
      }
      try { if let v = _storage._stopLoss {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._takeProfit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_Stop, rhs: Proto_Tradeapi_V1_Stop) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stopID != rhs_storage._stopID {return false}
        if _storage._securityCode != rhs_storage._securityCode {return false}
        if _storage._securityBoard != rhs_storage._securityBoard {return false}
        if _storage._market != rhs_storage._market {return false}
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._buySell != rhs_storage._buySell {return false}
        if _storage._expirationDate != rhs_storage._expirationDate {return false}
        if _storage._linkOrder != rhs_storage._linkOrder {return false}
        if _storage._validBefore != rhs_storage._validBefore {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._orderNo != rhs_storage._orderNo {return false}
        if _storage._tradeNo != rhs_storage._tradeNo {return false}
        if _storage._acceptedAt != rhs_storage._acceptedAt {return false}
        if _storage._canceledAt != rhs_storage._canceledAt {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._takeProfitExtremum != rhs_storage._takeProfitExtremum {return false}
        if _storage._takeProfitLevel != rhs_storage._takeProfitLevel {return false}
        if _storage._stopLoss != rhs_storage._stopLoss {return false}
        if _storage._takeProfit != rhs_storage._takeProfit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_StopLoss: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopLoss"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "activation_price"),
    2: .same(proto: "price"),
    3: .standard(proto: "market_price"),
    4: .same(proto: "quantity"),
    5: .same(proto: "time"),
    6: .standard(proto: "use_credit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.activationPrice) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.marketPrice) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._quantity) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.useCredit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.activationPrice != 0 {
      try visitor.visitSingularDoubleField(value: self.activationPrice, fieldNumber: 1)
    }
    if self.price != 0 {
      try visitor.visitSingularDoubleField(value: self.price, fieldNumber: 2)
    }
    if self.marketPrice != false {
      try visitor.visitSingularBoolField(value: self.marketPrice, fieldNumber: 3)
    }
    try { if let v = self._quantity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 5)
    }
    if self.useCredit != false {
      try visitor.visitSingularBoolField(value: self.useCredit, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_StopLoss, rhs: Proto_Tradeapi_V1_StopLoss) -> Bool {
    if lhs.activationPrice != rhs.activationPrice {return false}
    if lhs.price != rhs.price {return false}
    if lhs.marketPrice != rhs.marketPrice {return false}
    if lhs._quantity != rhs._quantity {return false}
    if lhs.time != rhs.time {return false}
    if lhs.useCredit != rhs.useCredit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_TakeProfit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TakeProfit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "activation_price"),
    2: .standard(proto: "correction_price"),
    3: .standard(proto: "spread_price"),
    4: .standard(proto: "market_price"),
    5: .same(proto: "quantity"),
    6: .same(proto: "time"),
    7: .standard(proto: "use_credit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.activationPrice) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._correctionPrice) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._spreadPrice) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.marketPrice) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._quantity) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.useCredit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.activationPrice != 0 {
      try visitor.visitSingularDoubleField(value: self.activationPrice, fieldNumber: 1)
    }
    try { if let v = self._correctionPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._spreadPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.marketPrice != false {
      try visitor.visitSingularBoolField(value: self.marketPrice, fieldNumber: 4)
    }
    try { if let v = self._quantity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 6)
    }
    if self.useCredit != false {
      try visitor.visitSingularBoolField(value: self.useCredit, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_TakeProfit, rhs: Proto_Tradeapi_V1_TakeProfit) -> Bool {
    if lhs.activationPrice != rhs.activationPrice {return false}
    if lhs._correctionPrice != rhs._correctionPrice {return false}
    if lhs._spreadPrice != rhs._spreadPrice {return false}
    if lhs.marketPrice != rhs.marketPrice {return false}
    if lhs._quantity != rhs._quantity {return false}
    if lhs.time != rhs.time {return false}
    if lhs.useCredit != rhs.useCredit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_StopQuantity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopQuantity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "units"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.units) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.units != .unspecified {
      try visitor.visitSingularEnumField(value: self.units, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_StopQuantity, rhs: Proto_Tradeapi_V1_StopQuantity) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.units != rhs.units {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_StopPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopPrice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "units"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.units) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.units != .unspecified {
      try visitor.visitSingularEnumField(value: self.units, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_StopPrice, rhs: Proto_Tradeapi_V1_StopPrice) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.units != rhs.units {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_CancelStopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelStopRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "stop_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stopID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.stopID != 0 {
      try visitor.visitSingularInt32Field(value: self.stopID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_CancelStopRequest, rhs: Proto_Tradeapi_V1_CancelStopRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.stopID != rhs.stopID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_CancelStopResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelStopResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "stop_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stopID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.stopID != 0 {
      try visitor.visitSingularInt32Field(value: self.stopID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_CancelStopResult, rhs: Proto_Tradeapi_V1_CancelStopResult) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.stopID != rhs.stopID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_GetStopsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetStopsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "include_executed"),
    3: .standard(proto: "include_canceled"),
    4: .standard(proto: "include_active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeExecuted) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeCanceled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.includeExecuted != false {
      try visitor.visitSingularBoolField(value: self.includeExecuted, fieldNumber: 2)
    }
    if self.includeCanceled != false {
      try visitor.visitSingularBoolField(value: self.includeCanceled, fieldNumber: 3)
    }
    if self.includeActive != false {
      try visitor.visitSingularBoolField(value: self.includeActive, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_GetStopsRequest, rhs: Proto_Tradeapi_V1_GetStopsRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.includeExecuted != rhs.includeExecuted {return false}
    if lhs.includeCanceled != rhs.includeCanceled {return false}
    if lhs.includeActive != rhs.includeActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_GetStopsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetStopsResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "stops"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.stops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stops, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_GetStopsResult, rhs: Proto_Tradeapi_V1_GetStopsResult) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.stops != rhs.stops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_NewStopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewStopRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "security_board"),
    3: .standard(proto: "security_code"),
    4: .standard(proto: "buy_sell"),
    5: .standard(proto: "stop_loss"),
    6: .standard(proto: "take_profit"),
    7: .standard(proto: "expiration_date"),
    8: .standard(proto: "link_order"),
    9: .standard(proto: "valid_before"),
  ]

  fileprivate class _StorageClass {
    var _clientID: String = String()
    var _securityBoard: String = String()
    var _securityCode: String = String()
    var _buySell: Proto_Tradeapi_V1_BuySell = .unspecified
    var _stopLoss: Proto_Tradeapi_V1_StopLoss? = nil
    var _takeProfit: Proto_Tradeapi_V1_TakeProfit? = nil
    var _expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _linkOrder: Int64 = 0
    var _validBefore: Proto_Tradeapi_V1_OrderValidBefore? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _clientID = source._clientID
      _securityBoard = source._securityBoard
      _securityCode = source._securityCode
      _buySell = source._buySell
      _stopLoss = source._stopLoss
      _takeProfit = source._takeProfit
      _expirationDate = source._expirationDate
      _linkOrder = source._linkOrder
      _validBefore = source._validBefore
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._clientID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._securityBoard) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._securityCode) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._buySell) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._stopLoss) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._takeProfit) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._expirationDate) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._linkOrder) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._validBefore) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 1)
      }
      if !_storage._securityBoard.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityBoard, fieldNumber: 2)
      }
      if !_storage._securityCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityCode, fieldNumber: 3)
      }
      if _storage._buySell != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._buySell, fieldNumber: 4)
      }
      try { if let v = _storage._stopLoss {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._takeProfit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._expirationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._linkOrder != 0 {
        try visitor.visitSingularInt64Field(value: _storage._linkOrder, fieldNumber: 8)
      }
      try { if let v = _storage._validBefore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_NewStopRequest, rhs: Proto_Tradeapi_V1_NewStopRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._securityBoard != rhs_storage._securityBoard {return false}
        if _storage._securityCode != rhs_storage._securityCode {return false}
        if _storage._buySell != rhs_storage._buySell {return false}
        if _storage._stopLoss != rhs_storage._stopLoss {return false}
        if _storage._takeProfit != rhs_storage._takeProfit {return false}
        if _storage._expirationDate != rhs_storage._expirationDate {return false}
        if _storage._linkOrder != rhs_storage._linkOrder {return false}
        if _storage._validBefore != rhs_storage._validBefore {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_NewStopResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewStopResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "stop_id"),
    3: .standard(proto: "security_code"),
    4: .standard(proto: "security_board"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stopID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.securityBoard) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.stopID != 0 {
      try visitor.visitSingularInt32Field(value: self.stopID, fieldNumber: 2)
    }
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 3)
    }
    if !self.securityBoard.isEmpty {
      try visitor.visitSingularStringField(value: self.securityBoard, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_NewStopResult, rhs: Proto_Tradeapi_V1_NewStopResult) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.stopID != rhs.stopID {return false}
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.securityBoard != rhs.securityBoard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
