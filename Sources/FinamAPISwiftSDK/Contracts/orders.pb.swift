// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/tradeapi/v1/orders.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Order placement properties.
/// Поведение заявки при выставлении в стакан.
enum Proto_Tradeapi_V1_OrderProperty: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// The residual of partially matched order is to stay in OrderBook.
  /// Неисполненная часть заявки помещается в очередь заявок биржи.
  case putInQueue // = 1

  /// The residual of partially matched order is to be cancelled.
  /// Неисполненная часть заявки снимается с торгов.
  case cancelBalance // = 2

  /// Filling the order only in case the posibility of immediate and full execution.
  /// Сделки совершаются только в том случае, если заявка может быть удовлетворена полностью и сразу при выставлении.
  case immOrCancel // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .putInQueue
    case 2: self = .cancelBalance
    case 3: self = .immOrCancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .putInQueue: return 1
    case .cancelBalance: return 2
    case .immOrCancel: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_OrderProperty: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_OrderProperty] = [
    .unspecified,
    .putInQueue,
    .cancelBalance,
    .immOrCancel,
  ]
}

#endif  // swift(>=4.2)

/// Conditional order types.
/// Типы условных ордеров.
enum Proto_Tradeapi_V1_OrderConditionType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Best Bid.
  /// Лучшая цена покупки.
  case bid // = 1

  /// Best Bid or Last trade price and higher.
  /// Лучшая цена покупки или сделка по заданной цене и выше.
  case bidOrLast // = 2

  /// Best Ask.
  /// Лучшая цена продажи.
  case ask // = 3

  /// Best Ask or Last trade price and lower.
  /// Лучшая цена продажи или сделка по заданной цене и ниже.
  case askOrLast // = 4

  /// Placement time. Parameter OrderCondition.time must be set.
  /// Время выставления заявки на Биржу. Параметр OrderCondition.time должен быть установлен.
  case time // = 5

  /// Coverage below specified.
  /// Обеспеченность ниже заданной.
  case covDown // = 6

  /// Coverage above specified.
  /// Обеспеченность выше заданной.
  case covUp // = 7

  /// Last trade price and higher.
  /// Сделка на рынке по заданной цене или выше.
  case lastUp // = 8

  /// Last trade price and lower.
  /// Сделка на рынке по заданной цене или ниже.
  case lastDown // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .bid
    case 2: self = .bidOrLast
    case 3: self = .ask
    case 4: self = .askOrLast
    case 5: self = .time
    case 6: self = .covDown
    case 7: self = .covUp
    case 8: self = .lastUp
    case 9: self = .lastDown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .bid: return 1
    case .bidOrLast: return 2
    case .ask: return 3
    case .askOrLast: return 4
    case .time: return 5
    case .covDown: return 6
    case .covUp: return 7
    case .lastUp: return 8
    case .lastDown: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_OrderConditionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_OrderConditionType] = [
    .unspecified,
    .bid,
    .bidOrLast,
    .ask,
    .askOrLast,
    .time,
    .covDown,
    .covUp,
    .lastUp,
    .lastDown,
  ]
}

#endif  // swift(>=4.2)

/// Order status.
/// Состояние заявки.
enum Proto_Tradeapi_V1_OrderStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not specified. Do not use.
  /// Значение не указано. Не использовать.
  case unspecified // = 0

  /// Order is not in OrderBook.
  /// Заявка не выставлена.
  case none // = 1

  /// Order is in OrderBook.
  /// Заявка выставлена.
  case active // = 2

  /// Order is canceled.
  /// Заявка отменена.
  case cancelled // = 3

  /// Order is matched.
  /// Заявка исполнена.
  case matched // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .none
    case 2: self = .active
    case 3: self = .cancelled
    case 4: self = .matched
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .none: return 1
    case .active: return 2
    case .cancelled: return 3
    case .matched: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Tradeapi_V1_OrderStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Tradeapi_V1_OrderStatus] = [
    .unspecified,
    .none,
    .active,
    .cancelled,
    .matched,
  ]
}

#endif  // swift(>=4.2)

/// Order placement properties.
/// Свойства выставления заявок.
struct Proto_Tradeapi_V1_OrderCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Condition type.
  /// Тип условия.
  var type: Proto_Tradeapi_V1_OrderConditionType = .unspecified

  /// Conditional value.
  /// Значение для условия.
  var price: Double = 0

  /// Placement time.
  /// Время выставления.
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// New Order Request.
/// Запрос на создание заявки.
struct Proto_Tradeapi_V1_NewOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Trading Board.
  /// Режим торгов.
  var securityBoard: String = String()

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String = String()

  /// Transaction direction.
  /// Направление сделки.
  var buySell: Proto_Tradeapi_V1_BuySell = .unspecified

  /// Order volume in lots.
  /// Количество лотов инструмента для заявки.
  var quantity: Int32 = 0

  /// Use credit. Not available in derivative market.
  /// Использовать кредит. Недоступно для срочного рынка.
  var useCredit: Bool = false

  /// Order price. Use "null" to place Market Order.
  /// Цена заявки. Используйте "null", чтобы выставить рыночную заявку.
  var price: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _price ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {self._price = nil}

  /// Unfilled order execution property.
  /// Свойства исполнения частично исполненных заявок.
  var property: Proto_Tradeapi_V1_OrderProperty = .unspecified

  /// Order placement properties.
  /// Свойства выставления заявок.
  var condition: Proto_Tradeapi_V1_OrderCondition {
    get {return _condition ?? Proto_Tradeapi_V1_OrderCondition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  mutating func clearCondition() {self._condition = nil}

  /// Order lifetime condition.
  /// Условие по времени действия заявки.
  var validBefore: Proto_Tradeapi_V1_OrderValidBefore {
    get {return _validBefore ?? Proto_Tradeapi_V1_OrderValidBefore()}
    set {_validBefore = newValue}
  }
  /// Returns true if `validBefore` has been explicitly set.
  var hasValidBefore: Bool {return self._validBefore != nil}
  /// Clears the value of `validBefore`. Subsequent reads from it will return its default value.
  mutating func clearValidBefore() {self._validBefore = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _price: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _condition: Proto_Tradeapi_V1_OrderCondition? = nil
  fileprivate var _validBefore: Proto_Tradeapi_V1_OrderValidBefore? = nil
}

/// NewOrderRequest result.
/// Результат выполнения NewOrderRequest.
struct Proto_Tradeapi_V1_NewOrderResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account Id.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Transaction Id, which can be used to cancel order or find corresponding order_no in Event service.
  /// Идентификатор транзакции, который может быть использован для отмены заявки или определения номера заявки в сервисе событий.
  var transactionID: Int32 = 0

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Cancel Order Request.
/// Запрос на отмену заявки.
struct Proto_Tradeapi_V1_CancelOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account Id.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Transaction Id, which can be used to cancel order or find corresponding order_no in Event service.
  /// Идентификатор транзакции, который может быть использован для отмены заявки или определения номера заявки в сервисе событий.
  var transactionID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CancelOrderRequest result.
/// Результат выполнения CancelOrderRequest.
struct Proto_Tradeapi_V1_CancelOrderResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account Id.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Transaction Id, which can be used to cancel order or find corresponding order_no in Event service.
  /// Идентификатор транзакции, который может быть использован для отмены заявки или определения номера заявки в сервисе событий.
  var transactionID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Get Orders Request.
/// Запрос списка заявок.
struct Proto_Tradeapi_V1_GetOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Include executed orders in response.
  /// Вернуть исполненные заявки.
  var includeMatched: Bool = false

  /// Include canceled orders in response.
  /// Вернуть отмененные заявки.
  var includeCanceled: Bool = false

  /// Include active orders in response.
  /// Вернуть активные заявки.
  var includeActive: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Order.
/// Заявка.
struct Proto_Tradeapi_V1_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Order No. Appear only when an order is placed in OrderBook.
  /// Биржевой номер заявки. Появляется после того, как заявка попадает в стакан.
  var orderNo: Int64 {
    get {return _storage._orderNo}
    set {_uniqueStorage()._orderNo = newValue}
  }

  /// Transaction Id . Assigned when a command for new order creation is sent.
  /// Идентификатор транзакции. Назначается после подачи команды на создание новой заявки.
  var transactionID: Int32 {
    get {return _storage._transactionID}
    set {_uniqueStorage()._transactionID = newValue}
  }

  /// Security Code.
  /// Тикер инструмента.
  var securityCode: String {
    get {return _storage._securityCode}
    set {_uniqueStorage()._securityCode = newValue}
  }

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String {
    get {return _storage._clientID}
    set {_uniqueStorage()._clientID = newValue}
  }

  /// Order status.
  /// Состояние заявки.
  var status: Proto_Tradeapi_V1_OrderStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Transaction direction.
  /// Направление сделки.
  var buySell: Proto_Tradeapi_V1_BuySell {
    get {return _storage._buySell}
    set {_uniqueStorage()._buySell = newValue}
  }

  /// Time of Order placement in UTC.
  /// Время регистрации заявки на бирже. В UTC.
  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Lot price.
  /// Цена за лот.
  var price: Double {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  /// Volume in lots.
  /// Количество, в лотах.
  var quantity: Int32 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  /// Residual volume in lots.
  /// Неисполненный остаток, в лотах.
  var balance: Int32 {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  /// Rejection reason or conditional order resolution.
  /// Причина отказа или вердикт по условной заявке.
  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Price currency.
  /// Валюта цены.
  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  /// Conditional order properties.
  /// Параметры условной заявки.
  var condition: Proto_Tradeapi_V1_OrderCondition {
    get {return _storage._condition ?? Proto_Tradeapi_V1_OrderCondition()}
    set {_uniqueStorage()._condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  var hasCondition: Bool {return _storage._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  mutating func clearCondition() {_uniqueStorage()._condition = nil}

  /// Order lifetime.
  /// Время действия заявки.
  var validBefore: Proto_Tradeapi_V1_OrderValidBefore {
    get {return _storage._validBefore ?? Proto_Tradeapi_V1_OrderValidBefore()}
    set {_uniqueStorage()._validBefore = newValue}
  }
  /// Returns true if `validBefore` has been explicitly set.
  var hasValidBefore: Bool {return _storage._validBefore != nil}
  /// Clears the value of `validBefore`. Subsequent reads from it will return its default value.
  mutating func clearValidBefore() {_uniqueStorage()._validBefore = nil}

  /// Time of order registration on the server in UTC.
  /// Время, когда заявка была зарегистрирована на сервере. В UTC.
  var acceptedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._acceptedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._acceptedAt = newValue}
  }
  /// Returns true if `acceptedAt` has been explicitly set.
  var hasAcceptedAt: Bool {return _storage._acceptedAt != nil}
  /// Clears the value of `acceptedAt`. Subsequent reads from it will return its default value.
  mutating func clearAcceptedAt() {_uniqueStorage()._acceptedAt = nil}

  /// Security Board.
  /// Основной режим торгов инструмента.
  var securityBoard: String {
    get {return _storage._securityBoard}
    set {_uniqueStorage()._securityBoard = newValue}
  }

  /// Market.
  /// Рынок.
  var market: Proto_Tradeapi_V1_Market {
    get {return _storage._market}
    set {_uniqueStorage()._market = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GetOrdersRequest result.
/// Результат GetOrdersRequest.
struct Proto_Tradeapi_V1_GetOrdersResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trade Account ID.
  /// Идентификатор торгового счёта.
  var clientID: String = String()

  /// Orders list.
  /// Список заявок.
  var orders: [Proto_Tradeapi_V1_Order] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_Tradeapi_V1_OrderProperty: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderConditionType: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderStatus: @unchecked Sendable {}
extension Proto_Tradeapi_V1_OrderCondition: @unchecked Sendable {}
extension Proto_Tradeapi_V1_NewOrderRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_NewOrderResult: @unchecked Sendable {}
extension Proto_Tradeapi_V1_CancelOrderRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_CancelOrderResult: @unchecked Sendable {}
extension Proto_Tradeapi_V1_GetOrdersRequest: @unchecked Sendable {}
extension Proto_Tradeapi_V1_Order: @unchecked Sendable {}
extension Proto_Tradeapi_V1_GetOrdersResult: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto.tradeapi.v1"

extension Proto_Tradeapi_V1_OrderProperty: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_PROPERTY_UNSPECIFIED"),
    1: .same(proto: "ORDER_PROPERTY_PUT_IN_QUEUE"),
    2: .same(proto: "ORDER_PROPERTY_CANCEL_BALANCE"),
    3: .same(proto: "ORDER_PROPERTY_IMM_OR_CANCEL"),
  ]
}

extension Proto_Tradeapi_V1_OrderConditionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_CONDITION_TYPE_UNSPECIFIED"),
    1: .same(proto: "ORDER_CONDITION_TYPE_BID"),
    2: .same(proto: "ORDER_CONDITION_TYPE_BID_OR_LAST"),
    3: .same(proto: "ORDER_CONDITION_TYPE_ASK"),
    4: .same(proto: "ORDER_CONDITION_TYPE_ASK_OR_LAST"),
    5: .same(proto: "ORDER_CONDITION_TYPE_TIME"),
    6: .same(proto: "ORDER_CONDITION_TYPE_COV_DOWN"),
    7: .same(proto: "ORDER_CONDITION_TYPE_COV_UP"),
    8: .same(proto: "ORDER_CONDITION_TYPE_LAST_UP"),
    9: .same(proto: "ORDER_CONDITION_TYPE_LAST_DOWN"),
  ]
}

extension Proto_Tradeapi_V1_OrderStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_STATUS_UNSPECIFIED"),
    1: .same(proto: "ORDER_STATUS_NONE"),
    2: .same(proto: "ORDER_STATUS_ACTIVE"),
    3: .same(proto: "ORDER_STATUS_CANCELLED"),
    4: .same(proto: "ORDER_STATUS_MATCHED"),
  ]
}

extension Proto_Tradeapi_V1_OrderCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.price != 0 {
      try visitor.visitSingularDoubleField(value: self.price, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_OrderCondition, rhs: Proto_Tradeapi_V1_OrderCondition) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.price != rhs.price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_NewOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "security_board"),
    3: .standard(proto: "security_code"),
    4: .standard(proto: "buy_sell"),
    5: .same(proto: "quantity"),
    6: .standard(proto: "use_credit"),
    7: .same(proto: "price"),
    8: .same(proto: "property"),
    9: .same(proto: "condition"),
    10: .standard(proto: "valid_before"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.securityBoard) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.buySell) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.quantity) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.useCredit) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.property) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._validBefore) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.securityBoard.isEmpty {
      try visitor.visitSingularStringField(value: self.securityBoard, fieldNumber: 2)
    }
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 3)
    }
    if self.buySell != .unspecified {
      try visitor.visitSingularEnumField(value: self.buySell, fieldNumber: 4)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt32Field(value: self.quantity, fieldNumber: 5)
    }
    if self.useCredit != false {
      try visitor.visitSingularBoolField(value: self.useCredit, fieldNumber: 6)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.property != .unspecified {
      try visitor.visitSingularEnumField(value: self.property, fieldNumber: 8)
    }
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._validBefore {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_NewOrderRequest, rhs: Proto_Tradeapi_V1_NewOrderRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.securityBoard != rhs.securityBoard {return false}
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.buySell != rhs.buySell {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.useCredit != rhs.useCredit {return false}
    if lhs._price != rhs._price {return false}
    if lhs.property != rhs.property {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs._validBefore != rhs._validBefore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_NewOrderResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewOrderResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "transaction_id"),
    3: .standard(proto: "security_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.transactionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.securityCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.transactionID != 0 {
      try visitor.visitSingularInt32Field(value: self.transactionID, fieldNumber: 2)
    }
    if !self.securityCode.isEmpty {
      try visitor.visitSingularStringField(value: self.securityCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_NewOrderResult, rhs: Proto_Tradeapi_V1_NewOrderResult) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.securityCode != rhs.securityCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_CancelOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.transactionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.transactionID != 0 {
      try visitor.visitSingularInt32Field(value: self.transactionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_CancelOrderRequest, rhs: Proto_Tradeapi_V1_CancelOrderRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_CancelOrderResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelOrderResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.transactionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.transactionID != 0 {
      try visitor.visitSingularInt32Field(value: self.transactionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_CancelOrderResult, rhs: Proto_Tradeapi_V1_CancelOrderResult) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_GetOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "include_matched"),
    3: .standard(proto: "include_canceled"),
    4: .standard(proto: "include_active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeMatched) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeCanceled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.includeMatched != false {
      try visitor.visitSingularBoolField(value: self.includeMatched, fieldNumber: 2)
    }
    if self.includeCanceled != false {
      try visitor.visitSingularBoolField(value: self.includeCanceled, fieldNumber: 3)
    }
    if self.includeActive != false {
      try visitor.visitSingularBoolField(value: self.includeActive, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_GetOrdersRequest, rhs: Proto_Tradeapi_V1_GetOrdersRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.includeMatched != rhs.includeMatched {return false}
    if lhs.includeCanceled != rhs.includeCanceled {return false}
    if lhs.includeActive != rhs.includeActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_no"),
    2: .standard(proto: "transaction_id"),
    3: .standard(proto: "security_code"),
    4: .standard(proto: "client_id"),
    5: .same(proto: "status"),
    6: .standard(proto: "buy_sell"),
    7: .standard(proto: "created_at"),
    8: .same(proto: "price"),
    9: .same(proto: "quantity"),
    10: .same(proto: "balance"),
    11: .same(proto: "message"),
    12: .same(proto: "currency"),
    13: .same(proto: "condition"),
    14: .standard(proto: "valid_before"),
    15: .standard(proto: "accepted_at"),
    16: .standard(proto: "security_board"),
    17: .same(proto: "market"),
  ]

  fileprivate class _StorageClass {
    var _orderNo: Int64 = 0
    var _transactionID: Int32 = 0
    var _securityCode: String = String()
    var _clientID: String = String()
    var _status: Proto_Tradeapi_V1_OrderStatus = .unspecified
    var _buySell: Proto_Tradeapi_V1_BuySell = .unspecified
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _price: Double = 0
    var _quantity: Int32 = 0
    var _balance: Int32 = 0
    var _message: String = String()
    var _currency: String = String()
    var _condition: Proto_Tradeapi_V1_OrderCondition? = nil
    var _validBefore: Proto_Tradeapi_V1_OrderValidBefore? = nil
    var _acceptedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _securityBoard: String = String()
    var _market: Proto_Tradeapi_V1_Market = .unspecified

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _orderNo = source._orderNo
      _transactionID = source._transactionID
      _securityCode = source._securityCode
      _clientID = source._clientID
      _status = source._status
      _buySell = source._buySell
      _createdAt = source._createdAt
      _price = source._price
      _quantity = source._quantity
      _balance = source._balance
      _message = source._message
      _currency = source._currency
      _condition = source._condition
      _validBefore = source._validBefore
      _acceptedAt = source._acceptedAt
      _securityBoard = source._securityBoard
      _market = source._market
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._orderNo) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._transactionID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._securityCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._clientID) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._buySell) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._price) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._quantity) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._balance) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._condition) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._validBefore) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._acceptedAt) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._securityBoard) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._market) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._orderNo != 0 {
        try visitor.visitSingularInt64Field(value: _storage._orderNo, fieldNumber: 1)
      }
      if _storage._transactionID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._transactionID, fieldNumber: 2)
      }
      if !_storage._securityCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityCode, fieldNumber: 3)
      }
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 4)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._buySell != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._buySell, fieldNumber: 6)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._price != 0 {
        try visitor.visitSingularDoubleField(value: _storage._price, fieldNumber: 8)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._quantity, fieldNumber: 9)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularInt32Field(value: _storage._balance, fieldNumber: 10)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 11)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 12)
      }
      try { if let v = _storage._condition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._validBefore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._acceptedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._securityBoard.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityBoard, fieldNumber: 16)
      }
      if _storage._market != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._market, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_Order, rhs: Proto_Tradeapi_V1_Order) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._orderNo != rhs_storage._orderNo {return false}
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._securityCode != rhs_storage._securityCode {return false}
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._buySell != rhs_storage._buySell {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._condition != rhs_storage._condition {return false}
        if _storage._validBefore != rhs_storage._validBefore {return false}
        if _storage._acceptedAt != rhs_storage._acceptedAt {return false}
        if _storage._securityBoard != rhs_storage._securityBoard {return false}
        if _storage._market != rhs_storage._market {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tradeapi_V1_GetOrdersResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOrdersResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tradeapi_V1_GetOrdersResult, rhs: Proto_Tradeapi_V1_GetOrdersResult) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
